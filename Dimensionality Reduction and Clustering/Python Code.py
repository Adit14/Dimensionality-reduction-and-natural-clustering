# -*- coding: utf-8 -*-
"""DVCA02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FH3DrrozND9TVMZr-WtjtdQX7l4-Djov
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE
import umap
import plotly.graph_objs as go
import plotly .offline as offline
import plotly.figure_factory as ff

"""**Dataset 1**

Importing Dataset
"""

dataset = pd.read_csv("sign_mnist.csv")
print(dataset.head())
print(dataset.shape)
print(dataset.info())
print(dataset.describe())

"""Splitting Labels and Features"""

X = dataset.drop(['label'], axis = 1) # Features
Y = dataset['label'] # Labels
print(type(X))
print(type(Y))
print(X.shape)
print(Y.shape)

"""Normalizing Features"""

feature_scaler = StandardScaler()
X_scaled = feature_scaler.fit_transform(X)

"""Converting Labels into List"""

Letters=list(dataset['label'])

"""Implementing t-SNE"""

tsne = TSNE(n_components = 2, perplexity = 20, n_iter = 2000)
x_tsne = tsne.fit_transform(X_scaled)

data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=Y, colorscale='Rainbow', opacity=0.5),
                                text=[f'Letters: {a}' for a in Letters],
                                hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='sign t-SNE.html')

"""Implementing UMAP"""

u = umap.UMAP(n_neighbors=15, min_dist=0.025,spread=5)
x_umap = u.fit_transform(X_scaled)

data = [go.Scatter(x=x_umap[:,0], y=x_umap[:,1], mode='markers',
                    marker = dict(color=Y, colorscale='Rainbow', opacity=0.5),
                                text=[f'digit: {a}' for a in digits],
                                hoverinfo='text')]

layout = go.Layout(title = 'UMAP Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='sign UMAP.html')

"""Dataset 2"""

#Importing Dataset
Customers = pd.read_csv('customers.csv')
print(Customers.info())
print(Customers.head())
print(Customers.shape)
print(Customers.describe())

#plotting corelation heatmap
correlations = Customers.corr()
figure = ff.create_annotated_heatmap(z = correlations.values, 
                                     x=list(correlations.columns),
                                     y = list(correlations.index),
                                     annotation_text = correlations.round(2).values,
                                     showscale = True)
offline.plot(figure,filename='customers_correlation heatmap.html')

"""From correlation heatmap it is observed that 'tenure' and 'MonthlyCharges' are highly correlated with 'TotalCharges'. Also there can be causation between these variables. Hence we need to drop column common column 'TotalCharges'"""

#Droping highly correlated column
Customers = Customers.drop(['TotalCharges'],axis=1)
print(Customers.info())

#Converting Categorical varibles to numerical variables
categorical_variables = ['gender', 'Partner', 'Dependents', 'PhoneService', 'MultipleLines', 
                         'InternetService', 'OnlineSecurity', 'OnlineBackup','DeviceProtection',
                         'TechSupport', 'StreamingTV', 'StreamingMovies', 'Contract', 
                         'PaperlessBilling', 'PaymentMethod']
customers = pd.get_dummies(Customers, columns = categorical_variables)

print(customers.info())
print(customers.head())

#Creating Subsets
#Subset 1 Personal Data
Subset1 = customers[['gender_Male','gender_Female','SeniorCitizen','Partner_Yes','Partner_No','Dependents_Yes',
                        'Dependents_No']]

#Subset 2 Contract Details
Subset2 = customers[['tenure','Contract_Month-to-month','Contract_One year','Contract_Two year','PaperlessBilling_No',
                                'PaperlessBilling_Yes','PaymentMethod_Bank transfer (automatic)','PaymentMethod_Credit card (automatic)',
                                'PaymentMethod_Electronic check','PaymentMethod_Mailed check','MonthlyCharges']]

#Subset 3 Services
Subset3 = customers[['PhoneService_No','PhoneService_Yes','MultipleLines_No','MultipleLines_No phone service','MultipleLines_Yes',
                     'InternetService_DSL','InternetService_Fiber optic','InternetService_No','OnlineSecurity_No',
                     'OnlineSecurity_No internet service','OnlineSecurity_Yes','OnlineBackup_No','OnlineBackup_No internet service',
                     'OnlineBackup_Yes','DeviceProtection_No','DeviceProtection_No internet service','DeviceProtection_Yes','TechSupport_No',
                     'TechSupport_No internet service','TechSupport_Yes','StreamingTV_No','StreamingTV_No internet service','StreamingTV_Yes',
                     'StreamingMovies_No','StreamingMovies_No internet service','StreamingMovies_Yes','MonthlyCharges']]

#Normalizing Data
feature_scaler = StandardScaler()
Norm1 = feature_scaler.fit_transform(Subset1)
Norm2 = feature_scaler.fit_transform(Subset2)
Norm3 = feature_scaler.fit_transform(Subset3)

"""Analysis of subset 1."""

#Elbow Plot to determine number of clusters
# Analysis on subset1 - Personal Data
# Finding the number of clusters (K) - Elbow Plot Method
inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(Norm1)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

"""From Elbow plot it is evident that there are 2 clusters in subset 1

Now identifying clusters by KMeans clustering to color the visualization by labels
"""

sub1_kmeans = KMeans(n_clusters = 2)
sub1_kmeans.fit(Norm1)

"""Now applying UMAP dimensionality reduction technique to visualize the subset 1 clusters in 2-Dimensions"""

red1 = umap.UMAP(n_neighbors=15, min_dist=0.1)
Norm1_umap = red1.fit_transform(Norm1)

gender = list(Customers['gender'])
sc = list(Customers['SeniorCitizen'])
par = list(Customers['Partner'])
dep = list(Customers['Dependents'])

data = [go.Scatter(x=Norm1_umap[:,0], y=Norm1_umap[:,1], mode='markers',
                    marker = dict(color=sub1_kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'gender: {a}; SeniorCitizen:{b}, Partner:{c}, Dependents:{d}' 
                                      for a,b,c,d in list(zip(gender,sc,par,dep))],
                                hoverinfo='text')]

layout = go.Layout(title = 'UMAP Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='Customers_UMAP1.html')

"""Analysis of Subset 2"""

#Elbow Plot to determine number of clusters
# Analysis on subset2 - Contract Data
# Finding the number of clusters (K) - Elbow Plot Method
inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(Norm2)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

"""From Elbow plot it is evident that there are 2 clusters in subset 2

Now identifying clusters by KMeans clustering to color the visualization by labels
"""

sub2_kmeans = KMeans(n_clusters = 2)
sub2_kmeans.fit(Norm2)

"""Now applying UMAP dimensionality reduction technique to visualize the subset 2 clusters in 2-Dimensions"""

red2 = umap.UMAP(n_neighbors=15, min_dist=0.1)
Norm2_umap = red2.fit_transform(Norm2)

tenure = list(Customers['tenure'])
con = list(Customers['Contract'])
pb = list(Customers['PaperlessBilling'])
pm = list(Customers['PaymentMethod'])
mc = list(Customers['MonthlyCharges'])

data = [go.Scatter(x=Norm2_umap[:,0], y=Norm2_umap[:,1], mode='markers',
                    marker = dict(color=sub2_kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'tenure: {a}; Contract:{b}, PaperlessBilling:{c}, PaymentMethod:{d}, MonthlyCharges:{e}' 
                                      for a,b,c,d,e in list(zip(tenure,con,pb,pm,mc))],
                                hoverinfo='text')]

layout = go.Layout(title = 'UMAP Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='Customers_UMAP2.html')

"""Analysis of Subset 3"""

#Elbow Plot to determine number of clusters
# Analysis on subset1 - Personal Data
# Finding the number of clusters (K) - Elbow Plot Method
inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(Norm3)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

"""From Elbow plot it is evident that there are 2 clusters in subset 2

Now identifying clusters by KMeans clustering to color the visualization by labels
"""

sub3_kmeans = KMeans(n_clusters = 2)
sub3_kmeans.fit(Norm3)

"""Now applying UMAP dimensionality reduction technique to visualize the subset 2 clusters in 2-Dimensions"""

red3 = umap.UMAP(n_neighbors=15, min_dist=0.1)
Norm3_umap = red3.fit_transform(Norm3)

ps = list(Customers['PhoneService'])
ml = list(Customers['MultipleLines'])
inter = list(Customers['InternetService'])
os = list(Customers['OnlineSecurity'])
ob = list(Customers['OnlineBackup'])
dp = list(Customers['DeviceProtection'])
ts = list(Customers['TechSupport'])
st = list(Customers['StreamingTV'])
sm = list(Customers['StreamingMovies'])
mc = list(Customers['MonthlyCharges'])

data = [go.Scatter(x=Norm3_umap[:,0], y=Norm3_umap[:,1], mode='markers',
                    marker = dict(color=sub3_kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'PhoneService: {a}; MultipleLines:{b}, InternetService:{c},MonthlyCharges{d}' 
                                      for a,b,c,d in list(zip(ps,ml,inter,mc))],
                                hoverinfo='text')]

layout = go.Layout(title = 'UMAP Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='Customers_UMAP3.html')